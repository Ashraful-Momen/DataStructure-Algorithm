I'll walk through the Quick Sort algorithm step by step using your array `[10,3,1,80,33,7,4,2]`. Let me trace through the partition function with the first element (10) as the pivot.

## Initial Setup
```
array = [10, 3, 1, 80, 33, 7, 4, 2]
l = 0, h = 7
pivot = array[0] = 10
i = 0 (left pointer)
j = 7 (right pointer)
```

## Step-by-Step Partition Process

### Round 1: Find elements to swap

**Step 1 - Move i right while array[i] ≤ pivot:**
```
i=0: array[0]=10, 10≤10 ✓, i++ → i=1
i=1: array[1]=3,  3≤10 ✓,  i++ → i=2  
i=2: array[2]=1,  1≤10 ✓,  i++ → i=3
i=3: array[3]=80, 80≤10 ✗, STOP at i=3
```

**Step 2 - Move j left while array[j] > pivot:**
```
j=7: array[7]=2, 2>10 ✗, STOP at j=7
```

**Step 3 - Check if i < j and swap:**
```
i=3, j=7 → 3<7 ✓, so swap array[3] and array[7]
Swap 80 ↔ 2
array = [10, 3, 1, 2, 33, 7, 4, 80]
```

### Round 2: Continue from current positions

**Step 4 - Continue moving i right:**
```
i=3: array[3]=2,  2≤10 ✓,  i++ → i=4
i=4: array[4]=33, 33≤10 ✗, STOP at i=4
```

**Step 5 - Continue moving j left:**
```
j=7: array[7]=80, 80>10 ✓, j-- → j=6
j=6: array[6]=4,  4>10 ✗,  STOP at j=6
```

**Step 6 - Check if i < j and swap:**
```
i=4, j=6 → 4<6 ✓, so swap array[4] and array[6]
Swap 33 ↔ 4
array = [10, 3, 1, 2, 4, 7, 33, 80]
```

### Round 3: Continue again

**Step 7 - Continue moving i right:**
```
i=4: array[4]=4, 4≤10 ✓, i++ → i=5
i=5: array[5]=7, 7≤10 ✓, i++ → i=6
i=6: array[6]=33, 33≤10 ✗, STOP at i=6
```

**Step 8 - Continue moving j left:**
```
j=6: array[6]=33, 33>10 ✓, j-- → j=5
j=5: array[5]=7,  7>10 ✗,  STOP at j=5
```

**Step 9 - Check if i < j:**
```
i=6, j=5 → 6<5 ✗, condition FAILS, EXIT while loop
```

### Final Step: Place pivot in correct position

**Step 10 - Swap pivot with array[j]:**
```
Swap array[l=0] with array[j=5]
Swap array[0]=10 with array[5]=7
Final array = [7, 3, 1, 2, 4, 10, 33, 80]
Return j=5 (pivot's final position)
```

## Result After First Partition
```
[7, 3, 1, 2, 4] | 10 | [33, 80]
   smaller       pivot   larger
   elements              elements
```

## Recursive Calls
Now Quick Sort recursively sorts:
1. **Left subarray**: `[7, 3, 1, 2, 4]` (indices 0-4)
2. **Right subarray**: `[33, 80]` (indices 6-7)

The process continues until all subarrays are sorted, eventually giving us:
```
Final sorted array: [1, 2, 3, 4, 7, 10, 33, 80]
```

The key insight is that after each partition, the pivot element (10) is in its final correct position, with all smaller elements to its left and all larger elements to its right.
